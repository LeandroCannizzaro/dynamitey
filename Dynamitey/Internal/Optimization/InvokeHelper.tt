<#@ template language="C#" #>
<#@ output extension="cs" #>
<#@ assembly  name="System.Core" #>
<#@ import namespace="System.Linq" #>

// 
//  Copyright 2011 Ekon Benefits
// 
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Reflection;
using System.Runtime.ExceptionServices;
using Dynamitey.Internal.Compat;

namespace Dynamitey.Internal.Optimization {

<# var cacheTypes = new []{"", "Get", "Set", "Constructor", "Member", "Direct"}; #>

<# foreach(var name in cacheTypes){ #>
    [SuppressMessage("ReSharper", "StaticMemberInGenericType")]
    internal static class Binder<#=name#>Cache<T> where T : class
    {
        private static IDictionary<BinderHash<T>, CallSite<T>>? _cache;

        private static readonly object _cacheLock = new object();

        internal static IDictionary<BinderHash<T>, CallSite<T>> Cache
        {
            get
            {
                lock (_cacheLock)
                {
                    return _cache ??= new Dictionary<BinderHash<T>, CallSite<T>>();
                }
            }
        }

        internal static readonly Action ClearCache = () =>
        {
            lock (_cacheLock)
            {
                _cache = null;
            }
        };
    }
<# } #>

    internal static partial class InvokeHelper
    {


        internal static readonly Type[] FuncKinds;
        internal static readonly Type[] ActionKinds;
		internal static readonly Type[] TupleKinds;

		internal static readonly IDictionary<Type,int> FuncArgs;
		internal static readonly IDictionary<Type,int> ActionArgs;
		internal static readonly IDictionary<Type,int> TupleArgs;

        static InvokeHelper()
        {
            FuncKinds = new []
                            {
<# for(int i=0; i <= 16; i++){ 
	var tCommas = String.Concat(Enumerable.Repeat(",",i));
#>
								typeof(Func<<#=tCommas#>>), //<#=i#>
<# } #>
                            };

            ActionKinds = new []
                            {
                                typeof(Action), //0
<# for(int i=1; i <= 16; i++){ 
	var tCommas = String.Concat(Enumerable.Repeat(",",i-1));
#>
								typeof(Action<<#=tCommas#>>), //<#=i#>
<# } #>
                            };

			TupleKinds = new []
                            {
<# for(int i=1; i <= 8; i++){ 
	var tCommas = String.Concat(Enumerable.Repeat(",",i-1));
#>
								typeof(Tuple<<#=tCommas#>>), //<#=i#>
<# } #>
                            };


			FuncArgs = FuncKinds.Zip(Enumerable.Range(0, FuncKinds.Length), (key, value) => new { key, value }).ToDictionary(k => k.key, v => v.value);
            ActionArgs = ActionKinds.Zip(Enumerable.Range(0, ActionKinds.Length), (key, value) => new { key, value }).ToDictionary(k => k.key, v => v.value);
			TupleArgs = TupleKinds.Zip(Enumerable.Range(1, ActionKinds.Length), (key, value) => new { key, value }).ToDictionary(k => k.key, v => v.value);

		
        }

		internal static dynamic TupleItem(dynamic tuple, int index){
			switch(index){
<# for(int i=1; i <= 7; i++){ #>
				case <#=i#>:
					return tuple.Item<#=i#>;
<# } #>
				default:
					return tuple.Rest;
			}
		}


        internal static void InvokeMemberAction(ref CallSite? callsite,
		                                            Type? binderType,
													int knownType,
													LazyBinder? binder,
                                                    InvokeMemberName name,
													bool staticContext,
                                                    Type context, 
                                                    string[]? argNames,
                                                    [DisallowNull] object target,
                                                    params object?[] args)
        {

            var tSwitch = args.Length;
            switch (tSwitch)
            {
#region Optimizations
<# for(int i=0; i <= 14; i++){ 
		var tobjectArgs = String.Join(",",Enumerable.Repeat(" object?",i+1));
		var tArrayArgs = String.Concat(Enumerable.Range(0,i).Select(it=>String.Format(", args[{0}]",it)));
#>
                case <#=i#>:
                    {
					    if(!(callsite is CallSite<Action<CallSite, <#=tobjectArgs#>>> tCallSite)){
							tCallSite = CreateCallSite<Action<CallSite, <#=tobjectArgs#>>>(binderType!,knownType, binder!, name, context, argNames, staticContext);
						    callsite=tCallSite;
						}
                        tCallSite.Target(tCallSite, target<#=tArrayArgs#>);
                        break;
                    }
<# } #>
#endregion
                default:
                    var argTypes = Enumerable.Repeat(typeof(object), tSwitch);
                    var delegateType = EmitCallSiteFuncType(argTypes, typeof(void));
                    Dynamic.InvokeCallSite(CreateCallSite(delegateType, binderType!,knownType, binder!, name, context, argNames), target, args);
                    break;

            }
        }

        

       

	



	    [return:MaybeNull]
        internal static TReturn InvokeMemberTargetType<TTarget,TReturn>(
										ref CallSite? callsite,
										Type? binderType,
										int knownType,
										LazyBinder? binder,
                                       InvokeMemberName name,
									 bool staticContext,
                                     Type context,
                                     string[]? argNames,
                                     [DisallowNull] TTarget target, params object?[] args)
        {

        

            var tSwitch = args.Length;

            switch (tSwitch)
            {
#region Optimizations
<# for(int i=0; i <= 14; i++){ 
		var tobjectArgs = String.Join(",",Enumerable.Repeat(" object?",i).Concat(new[]{"TReturn"}));
		var tArrayArgs = String.Concat(Enumerable.Range(0,i).Select(it=>String.Format(", args[{0}]",it)));
#>
                case <#=i#>:
                    {
					    if(!(callsite is CallSite<Func<CallSite, TTarget, <#=tobjectArgs#>>> tCallSite)){
							 tCallSite = CreateCallSite<Func<CallSite, TTarget, <#=tobjectArgs#>>>(binderType!,knownType,binder!, name, context, argNames, staticContext);
							 callsite =tCallSite;
						}
                        return tCallSite.Target(tCallSite, target<#=tArrayArgs#>);
                    }
<# } #>
#endregion
                default:
                    var argTypes = Enumerable.Repeat(typeof(object), tSwitch);
                    var delegateType = EmitCallSiteFuncType(argTypes, typeof(TTarget));
                    return Dynamic.InvokeCallSite(CreateCallSite(delegateType, binderType!,knownType, binder!, name, context, argNames), target, args)!;

            }
        }

     




		internal static Delegate WrapFuncHelper<TReturn>(dynamic invokable, int length)
        {
			  return length switch {
#region Optimizations
<# for(int i=0; i <= 16; i++){ 
				var tobjectArgs = String.Join(",",Enumerable.Repeat(" object",i).Concat(new[]{" TReturn"}));
  				var tArgList = String.Join(",",Enumerable.Range(0,i).Select(it=>"a"+(it+1)));
#>  					<#=i#> => new Func<<#=tobjectArgs#>>((<#=tArgList#>)=> invokable(<#=tArgList#>)),
<# } #>
#endregion	
				_ => (Delegate) new DynamicFunc<TReturn>(args=>(TReturn)Dynamic.Invoke((object)invokable,args))
			};
        }

        internal static Delegate WrapAction(dynamic invokable, int length)
        {
           	 return length switch {
#region Optimizations
				0 => (Delegate) new Action(()=>invokable()),
<# for(int i=1; i <= 16; i++){ 
				var tobjectArgs = String.Join(",",Enumerable.Repeat(" object",i));
				var tArgList = String.Join(",",Enumerable.Range(0,i).Select(it=>"a"+(it+1)));
#>  				<#=i#> => new Action<<#=tobjectArgs#>>((<#=tArgList#>)=> invokable(<#=tArgList#>)),
<# } #>
#endregion		
				_ => new DynamicAction(args=>Dynamic.InvokeAction((object)invokable,args))
			};
        }


        internal static object? FastDynamicInvokeReturn(Delegate del, dynamic?[] args)
        {
            dynamic tDel =del;
            switch(args.Length){
                default:
                    try
                    {
                        return del.DynamicInvoke(args);
                    }
                    catch (TargetInvocationException ex)
                    {
                        if (ex.InnerException is { } iex)
                        {
                            ExceptionDispatchInfo.Capture(iex).Throw();
                        }
                        throw;
                    }
#region Optimization
<# for(int i=1; i <= 16; i++){ 
	var tArgs = String.Join(",",Enumerable.Range(0,i).Select(it=>String.Format("args[{0}]",it)));
#>				case <#=i#>:
                    return tDel(<#= tArgs #>);
<# } #>
#endregion
            }
        }

        internal static void FastDynamicInvokeAction(Delegate del, params dynamic?[] args)
        {
            dynamic tDel =del;
            switch(args.Length){
                default: 
					try
                    {
						del.DynamicInvoke(args);
					}
					catch (TargetInvocationException ex)
                    {
                        if (ex.InnerException is { } iex)
                        {
                            ExceptionDispatchInfo.Capture(iex).Throw();
                        }
                        throw;
                    }
                    return;
#region Optimization
<# for(int i=1; i <= 16; i++){ 
	var tArgs = String.Join(",",Enumerable.Range(0,i).Select(it=>String.Format("args[{0}]",it)));
#>				case <#=i#>:
                    tDel(<#= tArgs #>);
                    return;
<# } #>
#endregion
            }
        }
    }
}
